ОСНОВНЫЕ ТРЕБОВАНИЯ

Сделать сегодня:
1. Сделать программу.


КС показать и проверить.
Премия только по предыдущему договору.
При напоминании навсегда, договор закрывается.

Сделать:

1.) Установка КБМ.
  б.) КБМ должен проходить проверки.
2.) Пользователь от имени которого производится печать.
3.) Сделать сортировку договоров по дате заключения.


ToDo:

Расчёт страховой премии:
  +1. Выбор базовой ставки из таблицы.
    Базовая ставка определяется по типу ТС.
    О категории водителей ничего неизвестно.  
  +2. Территориальный коэф-т. КТ. Выбрать из таблицы.
    Выбирается по месту прописки/регистрации собственника ТС.
  +3. Коэффициент бонус-малус. КБМ. Выбирается из таблицы.
    Если регион и группа владельца ТС содержатся в таблице для иностранцев, КБМ
    выбирается оттуда.
    Иначе, каждый клиент имеет свой класс, по которому КБМ выбирается из
    таблицы.
    При неограниченном списке водителей КБМ считается по собственнику,
    при ограниченном - по худшему КБМ водителей данного ТС.
  +4. Коэффициент количества лиц. КО.
    Если регион и группа владельца ТС содержатся в таблице для иностранцев, КО
    выбирается оттуда.
    Иначе, выбирается из таблицы КО, исходя из флага ограничения на число
    водителей. 1 или 1,7 (1,5).
  +5. Коэффициент стажа. КВС.
    Если регион и группа владельца ТС содержатся в таблице для иностранцев, КБМ
    выбирается оттуда.
    Иначе, КВС выбирается из таблицы отдельно для каждого вписанного водителя,
    и, затем, выбирается максимальный.
  +6. Выбирается коэффициент мощности двигателя. КМ.
    Выбирается только для легковых, иначе = 1.
  +7. Сезонный коэффициент. КС. Выбирается из таблицы.
  +8. Коэффициент срока страхования. КП.
    Выбирается только для иностранных владельцев и для транзита.
    Если регион и группа клиента содержатся в таблице для иностранцев, КП
    выбирается из соответствующей таблицы.

    Если установлен транзит, КП выбирается из таблицы с другими коэффициентами.

    Иначе КП = 1.

  +9. Коэффициент нарушений. КН. Выбирается из таблицы.
    Выбирается коэффициент для владельца транспортного средства.
  +10. Выбор формулы.
    а.) Флаг транзита в договоре, Факт наличия в таблице для иностранцев.
      Ключ типа формулы. Выбрать тип формулы.
    б.) Тип ТС.
    в.) Группа клиента.
    г.) По полученному ID (а, б, в - ключи) выбрать формулу.
  +11. Производится расчёт и вывод.

Коэффициенты, при сохранении, записываются в таблицу договоров.
При создании договора, правильные коэффициенты определяются на основе правил,
прописанных в законе. Затем, значения коэффициентов выбираются из таблицы.


1.) Учитывается ли как-то страховой случай? Учитывается была ли выплата по вине участника ДТП.
Если выплата была, _на след. год_ применяется повышающий коэф. при вписании водителя.
!!Не при продлении периода. В рамках года выплата не учитывается. Календарный год.
Учитывается по наихудшему водителю. Коэф-т КБМ. 
На следующие года учитывается. По таблице коэфициентов КБМ.

2.) Договор нельзя изменять? Да.
   При пролонгировании:
      1. Создаётся новый договор.
      2. Поля заполняются, в соответствии со старым.
      3. _После добавления в БД_, в старом ХП указывает пометку "Пролонгирован".
   Для замены полиса производится замена договора.
   Закрытие означает прекращение действия договора. Доступ закрыть.
   3 ХП: замена, пролонгация, закрытие.
  При пролонгации, срок действия распространяется на следующий год.
  Период возможно любой сделать.
  При замене, новая страховая премия суммируется с предыдущей.
  При замене, срок действия полиса никогда не меняется.
  В новом полисе, _которым_ заменили текущий.
  Время замены - время прихода клиента. Срок действия любой, но позже даты
  заключения.
  Замена производится по определённой причине. Надо спрашивать причину.
  Выводить диалог.

3.) Перед занесением клиента в БД, спрашивать надо ли заносить,
   если есть клиент с таким номером или паспортом (диалог с ожиданием).


ДОПОЛНИТЕЛЬНЫЕ ВОЗМОЖНОСТИ

Не реализовывать. Реализация возможна только после основных.

1.) Обмен сообщениями между пользователями.
2.) Работа со сканером штрих-кодов.
3.) Оповещение пользователей по SMS.
4.) "В случае, если клиент попадет в аварию, он сможет со своего мобильного
    телефона отправить сообщение на SMS-сервер страховщика. Через 30-40
    секунд ему перезвонит оператор CALL-центра компании, чтобы уточнить место
    и детали аварии, а в случае необходимости вызвать аварийные службы, дать
    консультацию и направить аварийного комиссара."
5.) Калькулятор ОСАГО.
6.) Создание подсистемы уведомления об ошибках программы.
7.) Предлагать параметры ТС, полученные по марке.
8.) Механизм проверки непротичоворечивости БД, доступный администратору.
   Поиск договоров с несуществующими клиентами, авто, группами и т.д.
9.) Журнал действий пользователя. Реализуется триггерами в отдельную таблицу.
   Виден только админу через интерфейс клиента.
10.) Диалог быстрого поиска договоров (по F3).
11.) История водителей и ТС (хранится, например, при смене номеров).
12.) Сохранять историю ТС (собственника и пред. номер. всю таблицу?)
!!!Изменений нет, только полная замена сущности. Водители и ТС.
13.) История изменений базы.
14.) Добавить настройку параметров печати: "Не печатать номера телефонов".
В заявлении.
15.) Выплаты.
16.) Переделать права группы на SET.
17.) Добавить к типу документа поле: группа колиента (документы только для физ.,
  только для юр. лиц). Отразить в интерфейсе.
18.) Доделать поиск INTERSECT.
19.) Добавить форму "Подождите" (и поле для показа операции пр.: "идёт поиск").
20.) Добавить ограничение по ресурсам сервера.
21.) Сделать функцию сортировки гридов.


Проверка дат:
1. Число конца страхования д.б. меньше на 1 день конца страхования.
2. Периоды как угодно.
3. Дата заключения меняется. Не трогать. "Договор подписан" на "Дата заклчючения договора".
4. При пролонгации, дата ставится на текущее+1 год. Пролонгация по договору не более одного года.
5. Дата начала совпадает с началом периода.

ОБНОВЛЕНИЯ ДАННЫХ

I. Сервер.

Триггеры записывают в таблицу обновлений данные обновления изменяющихся таблиц.
Структура таблицы оновлений:
  1.) k CLID - ключ.
  2.) TABLE_NAME - имя, обновляемой таблицы.
  3.) RECORD_ID - ключ, задействованной записи, в обновляемой таблице.
    Если составной, то разделяется символом ';'.
  4.) ACTION_TYPE - тип действия: вставка (i), изменение (u), удаление (d),
    необъявленное действие (a).
  5.) INSERT_TIME - время добавления записи в таблицу изменений.
  6.) USER_INSERTER - пользователь, добавивший запись.

Вызываемый триггер удаляет все записи таблицы фиксации обновлений,
время вставки которых меньше, чем:
текущее время - (self_info.REFRESH_TIME + 1) * 2,
где self_info.REFRESH_TIME - время автообновления клиентов, в секундах.

II. Клиент.

Клиент имеет объект, реализующий автоматическую проверку таблицы через
фиксированный временной интервал.

Основной объект называется "Диспетчер обновлений".

Данный объект состоит включает объект "Диспетчер обновления таблиц", который:
  а.) Хранит время последнего обновления запроса или таблицы.
  б.) Читает таблицу обновлений через установленные временные промежутки.
  в.) Сверяет время обновления, с сохранённым и, если требуется, создаёт
    событие, оповещающее о том, что таблица была обновлена.
  г.) Связывает очередь сообщений обновления одной записи одной таблицы в
    одно сообщение.
    Т.е., при каждом обновлении, для одной и той же записи одной таблицы
    выдаётся одно сообщение, сколько бы раз запись не обновлялась.
  д.) Осуществляет разбор составных ключей.

Диспетчер обновлений выполняет следующие функции:
  а.) Определяет тип обработки сообщения.
  б.) Сливает события, возникающие при обновлении записи справочника, в одно
    событие - "обновление справочника".
    Т.е., сколько бы записей в справочнике не было обновлено, всегда
    создаётся одно событие.
  в.) Оповещает элементы, которые должны быть обновлены.
  г.) Обрабатывает сообщения определённого типа самостоятельно.

Элементы, которые требуется обновлять:
  1.) Таблицы справочников и, соответственно, менеджер справочников.
  2.) Информацию на вкладках, отражающих свойства сущности:
    1. Клиент.
    2. ТС.
    3. Договор.
    Должны обновляться все видимые окна менеджеров, находящихся в состоянии
    просмотра или изменения сущностей.
    Обновления окнон менеджеров должны происходить через обновления сущностей,
    с ними связанных. Причём, должны обновляться как, вызываемые,
    так и вызывающие менеджеры.
  3.) Информацию в дереве страховых компаний и бланков.
  4.) Данные пользователей.

Случаи, в которых элементы не должны обновляться:
  1.) Обновление было выполнено активным окном менеджера.
    Не должно обновляться окно.
  2.) Обновление было выполнено менеджером справочников данного клиента.
    Не должно выпоняться перезагрузки справочника.
  3.) Пользователь был обновлён в менеджере пользователей.
    Обновление интерфейса не должно выполняться.

Типы обновлений:
  1.) Обновление справочника, не связанного с интерфейсом.
    Закрытие таблицы, если открыта.
    Контролируемые справочники:
      base_sum
      ins_koefs_km
      ins_koefs_ko
      ins_koefs_kp
      ins_koefs_ks
      ins_koefs_kvs
      ins_koefs_other
      territory_use
    В менеджере справочников, таблица переоткрывается, если необходимо.
  2.) Обновление справочника, сопряжённого с интерфейсом.
    Если обновилась запись в справочнике, данный справочник обновляется
    полностью. Все списки, построенные по данному справочнику, должны быть
    перестроены.
    Контролируемые справочники:
      client_types
      car_type
      carmark
      country
      city
      family_state
      insurance_class
      purpose_type
      region
      sex
      type_doc
      valuta
  3.) Обновление дерева компаний и бланков.
    При изменении структуры компаний, дерево должно перестраиваться.
    При добавлении бланка, соответствующий бланк должен появиться в дереве.
    При удалении/резервировании бланка, соответствующий бланк должен быть
    удалён из дерева.
    Смена реквизитов бланка не учитывается.
    Контролируемые таблицы:
      insurance_company
      blanks_journal
  4.) Обновление данных сущности.
    Данные сущности, в текущем менеджере должны обновляться, когда обновление
    было произведено не текущим менеджером.
    Должны обновляться данные всех активных менеджеров.
    Для таблицы client должен обновляться запрос напоминаний, если ID находится
    в предыдущем результате запроса.
    Контролируемые таблицы:
      car
      client
      dogovor
  5.) Данные пользователей.
    Контролируемые таблицы:
      user_data
    Должен меняться CurrentUser.

Замечания:
  1.) Когда обновляются справочники возможны следующие варианты:
    1. Удаление записи. Справочник переоткрывается. Списки перезаполняются.
      Ключи InnoDB автоматически устанавливает в NULL.
      ItemIndex'ы в открытых менеджерах заново устанавливаются по ID.

    2. Добавление записи. Справочник переоткрывается. Списки перезаполняются.
    3. Изменение записи:
      1) Изменение записи, не относящейся к данной сущности.
        Оповестить менеджеры об обновлении справочника.
      2) Изменение записи, относящейся к данной сущности.
        Изменение ID запрещено.
        Оповестить менеджеры об обновлении справочника.

Общий алгоритм работы диспетчера обновлений:

1.) Диспетчер обновления таблиц регистрирует обновление и вызывает событие.
2.) На данное событие реагирует диспетчер обновлений.
  Он обрабатывает событие, в зависимости от типа обновления, вызывая
  определённый обработчик.
3.) Главное окно (и, также менеджер договоров) реагируют на событие.
4.) Для типа 1, менеджер закрывает таблицу или запрос или оповещает
  менеджер справочников, если тот существует и активен.
5.) Для типа 2, вызывает перезаполнение, затребовав это через объект
  перезаполнения.
  Оповещает менеджер справочников, если тот существует и активен.
  Оповещает активные подчинённые менеджеры о том, что справочник был обновлён.
6.) Для типа 3 обновляет дерево компаний и бланков.
  1. Если были обновлены страховые компании, то дерево перестраивается.
  2. Если был зарезервирован или удалён бланк, он удаляется из дерева.
  3. Если был добавлен или разрезервирован бланк, он добавляется в дерево.
7.) Для типов 4, 5 обновляет данные, если требуется, и оповещает
  соответствующие подчинённые менеджеры, если они существуют и активны.
8.) Если менеджер получает уведомление, он:
  а.) Для типа 4:
    1. Проверяет отображает ли он обновившуюся сущность.
    2. Если это так, то он проверяет не была ли данная сущность обновлена
      данным менеджером.
    3. В случае, если пользователь внёс какие-либо изменения, запрашивает
      подтверждение загрузки.
      Если менеджер находится в режиме запроса, повторного запроса не
      производится.
    4. Когда менеджер вызвал подчинённого менеджера.
      1) Если был нажат "Ok" в подчинённом, запрос на обновление не выводится.
        Диспетчер обновлений запускается принудительно.
      2) Если были обновлены данные сущностей, входящих в сущность,
        управляемую данным менеджером, данные обновляются без предупреждения.
      3) Подчинённый менеджер оповещается об обновлении, если он активен.
    5. Если пользователь подтвердил загрузку, загружает обновлённые данные
      и обновляет элементы интерфейса.
  б.) Для типа 5:
    1. Если текущий пользователь был удалён, выводит сообщение и завершает
      сеанс работы.
    2. Если текущий пользователь был изменён, загружает изменённые данные и
      корректирует интерфейс, в соответствии с правами.
      Настройки не перезагружаются.
    3. Если был добавлен новый пользователь и активен менеджер пользователей и
      групп, оповещает его.

Общий алгоритм работы диспетчера обновления таблиц:
  1.) Чтение служебной таблицы и установка таймера в заданный интервал.
  2.) Первичный запуск.
  3.) Установка каждой таблице в списке времени обновления.
  4.) По таймеру:
    1. Чтение таблицы обновлений.
      Таблица обновлений упорядочивается по возрастанию времени обновления.
    2. Если найдена запись обновления, проход по списку таблиц.
    3. Если найдена запись с данным ID и типом обновления, для данной таблицы:
        1) Если такая запись не найдена в списке, она добавляется в список
          обновлённых записей. Аттрибут обновления в записи устанавливается в
          значение "Обновлена".
        2) Если такая запись найдена в списке записей данной таблицы:
          а.) Время обновления данной записи меньше или равно времени 
            обновления записи в списке. Для записи в списке, аттрибут
            обновления устанавливается в значение "Существует".
          б.) Время обновления данной записи больше времени обновления записи в
            списке. Для записи в списке, аттрибут обновления устанавливается в
            значение "Обновлена". Время обновления переустанавливается.
    4. Проход по списку таблиц.
      Аттрибут обновления записи имеет следующее значение:
        1) Обновлена.
          Создание события. Установка аттрибута в значение "Устарела".
        2) Существует. Установка аттрибута в значение "Устарела".
        3) Устарела. Удаление записи из объекта таблицы.

Каждый менеджер, кроме менеджера договоров, входящего в главное окно,
имеет методы, которые вызываются главным, по отношению к нему, менеджером, при
наступлении события обновления.

Объекты таблиц в диспетчере обновления таблиц:

type

// Тип обновления.
TUpdateType = (utInsert, utUpdate, utDelete, utAction);

// Тип ID записи.
TTableRecordID = array of variant;

// Тип записи в таблице.
TTableRecord = class(TObject)
public
  // Аттрибут обновления.
  property UpdateAttr: TUpdateAttr read FUpdAttr write FUpdAttr;
  property UpdateTime: TDateTime read FUpdTime write FUpdTime;
public
  property UpdateType: TUpdateType read FUpdType write SetUpdType;
  property RecordID: TTableRecordID read GetRecordID;
  property RecordIDUnparsed: string read FRecordIDU write SetRecordIDU;
end;

TTableObject = class(TObject)
private
public
  function GetRecord(const record_name: string): TTableRecord;
  // Добавляет запись, если такой записи ещё нет.
  function AddRecord(const record_name: string;
    const upd_type: TUpdateType): TTableRecord;
  // Удаление записи.
  procedure DelRecord(const r_index: integer);
  procedure ClearRecords();
public
  // Имя таблицы.
  property TableName: string read FTableName;
  // Флаг обновления.
  property UpdateFlag: boolean read FUpdFlag write FUpdFlag;
  // Обновлённые записи.
  property UpdatedRecords[index: integer]: TTableRecord read GetUpdRecords;
  property RecordsCount: integer read GetRecCount;
end;

// Тип события, создаваемого, при обновлении таблицы.
TTableUpdateEvent = procedure(const table_name: string;
  const update_type: TUpdateType; const record_id: TTableRecordID) of object;

// Диспетчер обновления таблиц.
TTablesRefreshDispatcher = class(TObject)
public
  procedure ReadSettings();
  procedure Refresh();
public
  property Active: boolean read GetActive write SetActive;
  property OnUpdate: TTableUpdateEvent read FOnUpdate write FOnUpdate;
  property OnStartUpdateCycle: TNotifyEvent read FOnStartUpdCycle
    write FOnStartUpdCycle;
  property OnEndUpdateCycle: TNotifyEvent read FOnEndUpdCycle
    write FOnEndUpdCycle;
end;

// Тип события, создаваемого, при обновлении сущности.
TEntityUpdateEvent = procedure(const entity_id: TTableRecordID;
  const update_type: TUpdateType) of object;
// Тип события, создаваемого, при обновлении справочника.
TInfoUpdateEvent = procedure(const table_name: string) of object;

// Диспетчер обновлений.
TDBUpdateDispatcher = class(TObject)
private
  FTRDispatcher: TTablesRefreshDispatcher;
protected
public
  procedure Refresh();
  property Active: boolean read GetActive write SetActive;
public
  property OnClientUpdate: TEntityUpdateEvent read FOnClientUpdate
    write FOnClientUpdate;
  property OnCarUpdate: TEntityUpdateEvent read FOnCarUpdate
    write FOnCarUpdate;
  property OnContractUpdate: TEntityUpdateEvent read FOnContractUpdate
    write FOnContractUpdate;
  property OnUserUpdate: TEntityUpdateEvent read FOnUserUpdate
    write FOnUserUpdate;
  property OnBlanksUpdate: TEntityUpdateEvent read FOnBlanksUpdate
    write FOnBlanksUpdate;
  property OnInsCompsUpdate: TEntityUpdateEvent read FOnInsCompsUpdate
    write FOnInsCompsUpdate;
  property OnInfosVisibleUpdate: TInfoUpdateEvent read FOnInfosVUpdate
    write FOnInfosVUpdate;
  property OnInfosInvisibleUpdate: TInfoUpdateEvent read FOnInfosIVUpdate
    write FOnInfosIVUpdate;
end;

{$IMPLICITEXCEPTIONS OFF}

Организация серверной части:
  1.) Обработка ошибок.
    а.) Процедура SetLastError(IN err_name CHAR(30)).
      Устанавливает код ошибки по константе.
    б.) Функция int GetLastError().
      Возвращает код ошибки. Устанавливает текущий код ошибки в ERR_NO_ERROR.
    в.) Таблица error_info.
      1. k ERROR_CODE. Код ошибки.
      2. ERROR_NAME. Константа ошибки.
      3. ERROR_DESCR. Описание ошибки.
    г.) Сессионная переменная err_code. Хранит код последней ошибки.
      Напрямую не используется.
    д.) Функция VARCHAR DescribeError(code INT). Возвращает описание ошибки.
  2.) self_info.

Добавление договора:
  1.) Открываю транзакцию.
  2.) Заношу сопутствующие данные:
    а.) Список водителей в БД (открывает транзакцию).
    б.) Резервирую бланк (открывает транзакцию).
      Всем соединениям должно быть известно, что данный бланк зарезервирован.
      Если транзакция не завершается, бланк нужно освободить.
  3.) Заношу договор в БД.
    1. Закрепляю бланк за договором.
    2. Вставляю договор.
    3. Переношу список водителей в БД.
    4. Обновляю историю.
  4.) Завершаю транзакцию.

Пролонгация договора:
  1.) Открываю транзакцию.
  2.) Заношу сопутствующие данные:
    а.) Список водителей в БД (открывает транзакцию).
    б.) Резервирую бланк (открывает транзакцию).
      Всем соединениям должно быть известно, что данный бланк зарезервирован.
      Если транзакция не завершается, бланк нужно освободить.
  3.) Заношу договор в БД.
    1. Закрепляю бланк за договором.
    2. Вставляю договор.
    3. Переношу список водителей в БД.
    4. Обновляю историю.
  4.) Изменяю предыдущий договор.
    1. Обновляю историю.
    2. Изменяю статус.
  5.) Завершаю транзакцию.

Программа автоматизирует работу страхового брокера.
Должно быть организовано:
I. Работа с БД.
1.) Ведение базы клиентов.
   Клиент - физическое или юридическое лицо.
   а.) Добавление (поиск перед добавлением).
      Перед добавлением в БД, должен выводиться список подходящих под
      критерии (ФИО, название организации) клиентов, которые уже имеются в БД.

      1. При добавлении юридического лица, указывается ИНН.
         Если запись с данным ИНН уже существует в БД, предлагается выбрать
         данную запись.
      2. Перед добавлением физ. лица запрашиваются серия и номер паспорта.
         Если запись с данными номером и серией существует, предлагается
         выбрать существующую запись.
      3. При добавлении обязателен ввод телефона клиента.
         Нельзя заносить клиентов без контактного телефона.
   б.) Поиск.
      Должен быть организован поиск клиентов по различным параметрам.
      По полному и неполному ФИО или названию организации. "Нечёткий" поиск.
   в.) Изменение.
   г.) Удаление (какое? удалять ли договора?).
2.) Ведение БД транспортных средств.
   а.) Добавление (поиск перед добавлением).
   б.) Поиск.
      Поиск проводится по ВИН (ин трансп. средства (по части номера))).
   в.) Изменение.
   г.) Удаление.
3.) Ведение БД договоров.
   а.) Добавление (поиск перед добавлением).
      Договор относится, как к клиенту, так и к ТС.
      В договоре должны быть комментарии:
         а.) В какой страховой фирме страховался клиент.
         б.) Дополнительно.
      Комментарии на печать не выводятся.
      Должно иметься поле, которое содержит число дней, за которые надо
      напомнить клиенту об окончании страховки.

   б.) Поиск.
      По номеру и др. данным.
   в.) Изменение.
      После печати полиса договор блокируется.
      Изменять договор разрешается только привилегированным пользователям.
      Если договор меняется, нужно спрашивать о сохранении.
      При открытии договора, режим изменения, включать отдельной кнопкой.
   г.) Удаление.
      Удалять может только администратор.
   д.) Пролонгация договора. Создаётся новый договор.
   е.) Замена договора.
      Замена происходит из-за изменений условий страхования или утери
      предыдущего полиса, смены владельца ТС, с учетом номера и серии
      предыдущего страхового полиса.
      При смене владельца ТС, изменяется договор. Старый полис, связанный с
      данным ТС, должен сохраняться, причём быть недоступен для изменения.
   ж.) Ведение истории договоров. Каждый договор содержит идентификатор
      предыдущего договора. Для первого договора - пустой.
   з.) Ввод номеров договоров. Список номеров договоров вводится доверенным
      пользователем. Номер подставляется автоматически.
      Потоковый ввод договоров.

II. Работа с отчётностью.
Создавать формы отчётности возможно из готового бланка ("по картинке").

1.) Заявления.
   а.) Создание.
      Создание и редактирование заявления.
      Проверка введенной информации для заявления.
      Должны печататься заявления установленной формы. (на двух сторонах).
   б.) Вывод на печать.
2.) Полисы.
   а.) Создание на базе договора.
   б.) Вывод на печать.
3.) Общая отчётность
   а.) Отчёт по выбранным договорам.
   б.) Отчёт по закончившимся договорам.
   в.) Экспорт договоров в форматы XML.
   г.) Вывод отчёта "Бордеро".
   -д.) Экспорт договоров по электронной почте в виде zip архивов.

III. Расчёты.
1.) Расчёт страховых выплат.
   Должен вестись расчёт выплат, в соответствии с установленной методикой
   расчёта.
   Каждому водителю присваивается класс. У всех договоров для данного водителя
   один класс.
   При расчёте класс берётся по наихудшему водителю в договоре.

IV. Доступ и безопасность.
1.) Клиент-серверная модель.
   Симм. шифрование трафика между сервером и клиентом для защиты от перехвата.
2.) Резервное копирование БД.
   Создание ежедневных резервных копий базы данных: каждый день автоматически
   создается папка со снимком базы данных на данный день.
   Все изменения, в БД, сделанные за день, должны быть одобрены администратором.
3.) Взаимодействие версий.
  Вести версию БД (чтобы избежать конфликта версий программы (пр. новые поля)).
4.) Разграничение полномочий пользователей.
   Три типа групп пользователей:
      1.) Администратор
      2.) Привилегированный пользователь.
      3.) Обычный агент.

   Доступ разграничивается на уровне сервера СУБД. Используются средства MySQL
   по определению привилегий на доступ к таблицам.
   Каждый агент добавляется администратором и имеет:
      1.) Имя пользователя.
      2.) Хост.
      3.) ФИО.
      4.) Контактный телефон.
      5.) Адрес.
   Доп. данные хранятся в таблице users, доступной только администратору.
   В служебной таблице СУБД user хранятся права пользователей и пароль.
   1 и 2 являются первичным ключом.
   Группа определяется набором прав. Права хранятся в таблице прав группы.
   Прямое изменение любой таблицы БД запрещено всем, кроме администратора.

   Добавление в систему агентов с указанием их ФИО и пункта страхования.
   Должен иметься простой графический административный интерфейс,
   отвечающий за работу с пользователями (добавление, удаление, блокировка и
   назначение групп). Администратор может изменять групповые права.

V. Разное.
1.) Напоминания.
   Напоминание о клиентах, у которых заканчивается срок страховки.
   На текущую дату, должна существовать отдельная таблица (интерфейсно),
   отображающая клиентов, у которых скоро закончится срок страховки.
   У клиента должен быть флаг, управляющий занесением в таблицу.
   В таблицу не должны заноситься клиенты, полис которых был продлён.
   Постоянное напоминание (клиенту позвонили, но взнос он так и не оплатил).

Проектирование.

СТРУКТУРА ПРОГРАММННОГО КОМПЛЕКСА

Программа состоит из:
   I. Клиента СУБД.
      Обеспечивает связь с сервером СУБД. Тонкий клиент служит для ввода и
      отображения данных в удобной для пользователя форме.
      Клиент взаимодествует с СУБД, используя запросы и вызовы хранимых
      процедур. Причём, предпочтение отдаётся хранимым процедурам.
      Клиент состоит из:
         1.) Интерфейса пользователя.
            Клиент отвечает за интерфейсную защиту от неграмотных действий
            пользователя.
         2.) Клиента СУБД.
         3.) Рассчётных механизмов.
            Рассчёт требуемых параметров, исходя из имеющихся данных. Например,
            рассчёт страховой премии.
   II. Сервера СУБД.
      Сервер отвечает за:
         1.) Ведение БД.
         2.) Разграничение прав пользователей.
         3.) Защиту от логической несвязности БД.
   III. Дополнительных служб сервера.
      Отвечают за:
         1.) Сохранение резервной копии БД.
         2.) Защиту от НСД.

Программные реализации сервера используют СУБД MySQL (желательно на базе Unix
подобных ОС).
Для архивирования БД используются стандартные средства ОС или средства
сторонних разработчиков. ОС управляется, используя штатные средства.
Возможна, но крайне нежелательна реализация сервера, используя windows.

Клиент, в базовом варианте, реализован, как программа под ОС windows и Unix
подобные ОС, в частности Linux, а также ОС с её бинарной эмуляцией или
поддерживаемых средой разработки. Базовый вариант клиента написан в среде
Free Pascal/Lazarus.

ПРОЕКТИРОВАНИЕ КЛИЕНТА

Клиент предназначается для ввода команд пользователя и отображения результатов.
Он представляет собой исполнимое приложение, запускаемое в оконной среде.
При запуске, появляется главное окно, откуда доступны все функции клиента.
Клиент является программой.
Он представляет собой промежуточное звено между сервером и СУБД.
Клиент логически подразделяется на три слоя:
  1.) Слой взаимодействия с пользователем.
  2.) Слой объектного взаимодействия.
  3.) Слой взаимодействия с СУБД.

 +-->[Слой взаимодействия с пользователем] <- активный клиент.
 | Cобытия         |
 |         +-------+------+
 |         |   [Сервер]   | <- ОРП является пассивным сервером для
 +---------+   [ ОРП  ]   |  отображения/контроллера.
           |   [Клиент]   | <- ОРП - клиент для слоя взаимодействия с СУБД.
           +-------+------+
                   |
      [Слой взаимодействия с СУБД] <- пассивный сервер.

СЛОЙ ВЗАИМОДЕЙСТВИЯ С ПОЛЬЗОВАТЕЛЕМ

Слой, взаимодействия с пользователем представлен пользовательским интерфейсом.
Интерфейс выполняет следующие задачи:
  1.) Отображение данных (представление).
  2.) Ввод данных (контроллер).
Интерфейс связан со слоем ОРП. Представление отображает состояние слоя ОРП.
Контроллер изменяет состояние слоя ОРП.
Элементы интерфейса совмещают в себе функции контроллера и представления.
Т.е., как ввода, так и отображения данных.
Отдельные элементы интерфейса могут взаимодействовать непосредственно со
слоем СУБД, что определяется особенностями конкретной среды, используемой
для реализации клиента.
Структурно, клиент состоит из:
  1.) Иерархии логических единиц - менеджеров.
  2.) Прочих интерфейсных единиц.
Менеджер - это единица интерфейса, представляющая возможность работы с
одной сущностью предметной области. Каждый менеджер представлен окном или
несколькими окнами. Единицы интерфейса, не предназначенные для работы с
сущностями предметной области, не являются менеджерами.
Хотя, в целях унификации интерфейса, для пользователя, их окна могут иметь
заголовок "Менеджер". Менеджеры логически выделяются тем, что они имеют общий
базовый класс.
Сам клиент является менеджером, представляющим интерфейс для работы с
предметной областью и смежными областями.
Иерархия интерфейсных единиц:

                          [Главный менеджер]
                                  |
         +------------------+-------------+---------------+
         |                  |             |               |
[Менеджер договоров]  [Менеджер клиентов] | [Менеджер транспортных средств]
         |                                |
         |                                |
[Окно выбора бланка полиса]               |
                                          |
                                          |
          +----------------------+--------+-----------+-----------+
          |                      |                    |           |
[Ввод пустых бланков]  [Пользователи и группы]  [Справочники]  [Прочее]


ОБОБЩЁННАЯ СТРУКТУРА МЕНЕДЖЕРА

Менеджер - интерфейсная единицая, предоставляющая возможность управления
одной из сущностей предметной области.

Менеджер осуществляет поиск, отображение, изменение сущности, а также
выполнение специфических для сущности действий.

Менеджер представляет собой модуль, имеющий вход и выход по данным.
На вход подаётся коллекйия сущностей и номер выбранной сущности.
На выходе менеджер также предоставляет коллекцию сущностей, с которыми он
оперировал и номер выбранной сущности.
Входные и выходные данные представляют собой объекты или коллекции объектов.

С точки зрения управления, менеджер является автономным элементом.
Окно менеджера служит для взаимодействия пользователя с программой.
Одновременно возможно работать только с одним окном.
Но, при необходимости предоставить пользователю возможность работаты с данными,
с которыми менеджер не работает, он может вызывать другие менеджеры, для
получения требуемого набора данных.

Связь по управлению имеет только вход. Входом является вызов менеджера.
Далее, менеджер берёт на себя инициативу и работает в автономном режиме.
На вход передаются данные и режим менеджера: поиск или просмотр.

Также имеются косвенные связи по данным и управлению.
Например, для своей работы менеджер использует общие для других программные
объекты: модули, объекты запросов, функции.

Каждый менеджер имеет флаг, определяющий режим его работы.
Менеджер может находиться в следующих режимах:
   1.) Просмотр сущности.
   2.) Изменение сущности.
   3.) Создание сущности.
   4.) Поиск сущности.

Реализованы следующие менеджеры:
   1.) Менеджер договор. Представлен главным окном и редактором договоров.
      С программной точки зрения, менеджером является редактор договоров.
   2.) Менеджер пользователей. Представлен отдельным окном.
   3.) Менеджер транспортных средств. Представлен отдельным окном.

ОБЩАЯ СТРУКТУРА ИНТЕРФЕЙСА

Интерфейс SDI типа. Классический. Одно окно является основным и рабочим.
По мере необходимости, показываются дополнительные окна.
Слева - дерево "каталогов". Каталоги - страховые компании.
В каталогах содержатся договора. Договора отображаются в таблице справа.
Справа по центру - основное рабочее окно, содержащее журнал договоров, в виде
таблицы.
Ниже - окно напоминания.
Справа снизу - панель управления, содержащая следующие элементы:
   1.) Создать договор.
   2.) Открыть договор.
   3.) Поиск.
   4.) Менеджер ТС.
   5.) Менеджер клиентов.
   6.) История договоров.

Сверху - главное меню.
Снизу - строка статуса.

Дополнительные окна

Общие:
I. Менеджер клиентов.
1.) Список клиентов. Совмещён с поиском клиентов.
3.) Редактор клиента.

II. Менеджер ТС.
1.) Список ТС. Совмещён с поиском ТС.
3.) Редактор ТС.

III. Менеджер договоров.
1.) Список договоров в главном окне.
2.) Редактор договора.
   Представляет собой окно, содержащее следующие вкладки:
      а.) Вкладка предварительного рассчёта страховой стоимости.
      б.) Вкладка заполнения заявления.
         Содержит:
            1. Ссылку на страхователя. При выборе открывается менеджер
               клиентов, в котором возможно выбрать существующего клиента или
               завести нового.
            2. Ссылку на собственника.
            3. Ссылку на ТС. При выборе открывается менеджер ТС.
            4. Список водителей. Занесение в список через менеджер ТС.
         Хранить ФИО агента, составившего договор.
3.) История договоров.
  В окне истории договоров, отображаются:
    1. Операции по данному   договору и дата выполнения.
    2. Общие сведения о договоре.
    3. Все предыдущие договора, которые были заменены или пролонгированы на
      данный.
  
4.) Окно ввода договоров.
  Окно ввода имеет поля для ввода серии договоров, и диапазона номеров.
  Перед вводом, выбирается страховая компания, которой принадлежат бланки
  полисов.
  Снизу окна находится таблица, которая содержит сформированный список.
  В данной таблице возможно удалить полисы с несуществующими номерами.
  После нажатия "Ok" или "Применить", содержимое таблицы заносится в БД.

IV.
1.) Окна вывода документов на печать (полиса и заявления).

Административные:
1.) Менеджер справочников и специальных таблиц.
   Список справочников и таблица для их отображения.
2.) Менеджер пользователей и групп.
   а.) Просмотр пользователей. Совмещён с редактором пользователей.
   б.) Просмотр и изменение прав группы.

Интерфейс должен обращаться к пользователю по имени. Используется помощник.

После запуска программы, будут прочитаны настройки.
Если программа запускается первый раз или отстуствуют необходимые для
авторизации данные, будет показано окно приветствия/авторизации.
В данном окне должно настраиваться:
   1.) Адрес сервера БД.
   2.) Название БД (не обязательно, м.б. жёстко заданным).
   3.) Имя пользователя, для подключения к БД.
   4.) Пароль.
   5.) Место для сохранения текущих настроек.

После нажатия на кнопку подтверждения входа, настройки сохраняются в выбранном
месте. Если настройки не удаётся сохранить, программа выводит предупреждение.

СЛОЙ ОБЪЕКТНОГО ВЗАИМОДЕЙСТВИЯ

Предназначен для организации взаимодействия менеджеров между собой.
Представлен объектами, инкапсулирующими свойства основных сущностей.
Данными объектами обмениваются менеджеры.

Объекты должны иметь следующие возможности:
  1.) Произвольной установки определённых полей.
  2.) Самостоятельной загрузки полей из источника данных.
  3.) Сохранения состояния объекта в БД.
  4.) Автоматического управления памятью.
  5.) Выполнения специфических для сущности действий.

Базовые классы:
  1.) Абстрактная сущность. TEntity.
  Представляет собой класс, содержащий общие для всех сущностей поля и методы.
  Сущность может находиться в следующих состояних:
    1. Новая сущность.
    2. Изменённая сущность.
    3. Сохранённая сущность.
  Сущность загружает себя из источника данных. Также сохраняет себя в БД.
  
  Если необходимых полей нет, источник
  данных вызывает исключение и загрузка прерывается.
  Сохранённая или изменённая сущности пытаются найти в источнике данных
  соответствующую запись, сравнивая поля-идентификаторы. Если запись найдена,
  производится загрузка. Новая сущность загружает данные из первой записи
  источника.
  Имеет следующие интерфейсные элементы:
    1. Загрузить из БД.
    2. Сохранить в БД.
    3. Удалить данную сущность из БД.
    4. Удалить данный объект из коллекции.
    5. Проверить соответствие ID.
    6. Узнать сохранены ли изменения.
    7. Проверить не обновилась ли сущность в БД (если существует).
  2.) Коллекция сущностей. TEntityesCollection.
    Коллекция отвечает за создание и разрушение сущностей, управление памятью.
    1. Создать сущность.
    2. Получить сущность по ID.
    3. Проверить существует ли сущность по ID (без получения данных).
    4. Удалить сущность с заданным ID из коллекции.
    5. Получить число элементов в коллекции.

//
// Абстрактная сущность.
//

TLoadType = (ltAuto, ltNew, ltSaved);

TEntityNotifyEvent = procedure(Sender: TEntity) of object;

TEntity = class(TCollectionItem)
private
  FDataSource: TDataSource;
  FSaved: boolean;
  FIsNew: boolean;
  FOnChanged: TEntityNotifyEvent;
  FOnDBDeletion: TEntityNotifyEvent;
  FOnDestroy: TEntityNotifyEvent;
protected
  // Устанавливает поля сущности, при её переинициализации.
  procedure ReInitEntity(); virtual;
  // Устанавливает поля сущности, при её загрузке из базы.
  function SetEntityData(): boolean; virtual; abstract;
protected
  // Вызывается сущностью, при добавлении новой записи в БД.
  function InsertRecord(): boolean; virtual; abstract;
  // Вызывается функцией DB_Load, при загрузке новой сущности из БД.
  function LoadNewRecord(): boolean; virtual;
  // Вызывается функцией DB_Load, при загрузке новой сущности из БД.
  function LoadSavedRecord(): boolean; virtual; abstract;
  // Вызывается функцией DB_Save сущности, при изменении существующей в БД
  // записи.
  function UpdateRecord(): boolean; virtual; abstract;
  // Вызывается функцией DB_Delete сущности, при удалении сущности из БД.
  function DeleteRecord(): boolean; virtual; abstract;
protected
  procedure DoOnChanged();
  procedure DoOnDBDeletion();
  procedure DoOnDestroy();
  property OnChanged: TEntityNotifyEvent read FOnChanged write FOnChanged;
  property OnDBDeletion: TEntityNotifyEvent read FOnDBDeletion
    write FOnDBDeletion;
  property OnDestroy: TEntityNotifyEvent read FOnDestroy write FOnDestroy;
  // Узнать сохранены ли изменения.
  property IsSaved: boolean read FSaved write FSaved;
  // Это вновь созданная запись или, загруженная из БД.
  property IsNew: boolean read FIsNew write FIsNew;
protected
  // Коллекция-владелец.
  function GetCollection(): TEntityesCollection;
public
  // Загрузить из БД.
  function DB_Load(const load_type: TLoadType = ltAuto): boolean; virtual;
  // Сохранить в БД.
  function DB_Save(): boolean; virtual;
  // Удалить данную сущность.
  function DB_Delete(): boolean; virtual;
  // Удалить данный объект.
  procedure DeleteSelf();
  // Проверить соответствие ID.
  function CheckID(const id_fields: array of variant): boolean;
    virtual; abstract;
  // Проверить не обновилась ли сущность в БД (если существует).
  function DB_IsUpdated(): boolean; virtual;
  // Скопировать поля источника в данную запись.
  procedure Assign(Source: TEntity); virtual;
public
  // Источник данных, для загрузки.
  property DataSource: TDataSource read FDataSource write FDataSource;
public
  constructor Create(ACollection: TCollection); override;
  destructor Destroy; override;
end;

//
// Коллекция сущностей.
//

TEntityesCollection = class(TCollection)
protected
  function GetItem(const AIndex: Integer): TEntity;
public
  // Получить сущность по ID.
  function GetEntityByID(const id_fields: array of variant): TEntity;
  // Получить индекс заданной сущности или -1.
  function GetEntityIndex(const ent: TEntity): integer;
  // Проверить существует ли сущность по ID (без получения всех данных).
  function EntityExists(const id_fields: array of variant): boolean;
  // Проверить содержится ли данная сущность в коллекции.
  function EntityExists(const ent: TEntity): boolean;
  // Удалить сущность с заданным ID из БД.
  function DB_DelEntity(const id_fields: array of variant): boolean;
  // Создать сущность.
  function Add(): TEntity;
  // Удалить сущность с заданным ID из коллекции.
  function DelEntity(const id_fields: array of variant): boolean;
public
  // Элементы.
  property Items[AIndex: Integer]: TEntity read GetItem write SetItem; default;
  // Текущий элемент.
  property ItemIndex: integer read FItemIndex write SetItemIndex;
public
  constructor Create(AItemClass: TEntityClass); virtual;
  destructor Destroy; override;
public
  
end;

//
// Клиент.
//

TClientEntity = class(TEntity)
private
public
  property IDClient: variant read FIDClient write SetID;
  property IDClientType: variant read FClientType write SetClientType;
  property IDClientTypeGroup: variant read GetClientTypeGroup;
  property ClientName: variant read FClientName write SetClientName;
  property ClientPathronimyc: variant read FClientPathr write SetClientPathr;
  property ClientSurname: variant read FClientSurname write SetClientSurname;
  property INN: variant read FINN write SetINN;
  property IDDocType: variant read FDocType write SetDocType;
  property DocType: variant read GetDocTypeName;
  property DocSer: variant read FDocSer write SetDocSer;
  property DocNum: variant read FDocNum write SetDocNum;
  property Postindex: variant read FPostindex write SetPostindex;
  property Country: variant read FCountry write SetCountry;
  property Birthday: variant read FBirthday write SetBirthday;
  property Age: variant read GetAge;
  property Stage: variant read GetStage;
  property IDCountry: variant read FIDCountry write SetCountry;
  property CountryName: variant read GetCountryName;
  property IDRegion: variant read FIDRegion write SetRegion;
  property RegionName: variant read GetRegionName;
  property IDCity: variant read FIDCity write SetCity;
  property CityName: variant read GetCityName;
  property GeoGroup: variant read GetGeoGroup;
  property Town: variant read FTown write SetTown;
  property Street: variant read FStreet write SetStreet;
  property Home: variant read FHome write SetHome;
  property Corpus: variant read FCorpus write SetCorpus;
  property FlatNum: variant read FFlatNum write SetFlat;
  property PhoneHome: variant read FPhoneHome write SetPhoneHome;
  property BusinessPhone: variant read FBusinessPhone write SetBusinessPhone;
  property LastCallDate: variant read FLastCallDate;
  property CellPhone: variant read FCellPhone write SetCellPhone;
  property LicenseSer: variant read FLicenseSer write SetLicenseSer;
  property LicenseNum: variant read FLicenseNum write SetLicenseNum;
  property StartDrivingDate: variant read FSDDate write SetSDDate;
  property IDSocialState: variant read FSocialState write SetSocialState;
  property SocialState: variant read GetSocialState;
  property IDFamilyState: variant read FFamilyState write SetFamilyState;
  property GrossViolations: variant read FGViolations write SetGViolations;
  property IDInsuranceClass: variant read FInsClass write SetInsClass;
  property InsuranceClass: variant read GetInsClassName;
  property Comments: TStringList read FComments write SetComments;
  property DateInsert: variant read FDateInsert;
  property DateUpdate: variant read FDateUpdate;
  property UserInsertName: variant read FUIName;
  property UserUpdateName: variant read FUUName;
  property FullName: variant read GetFullName;
  property FullAddress: variant read GetFullAddress;
  property FullDoc: variant read GetFullDoc;
end;

//
// Транспортное средство.
//

TCarEntity = class(TEntity)
private
protected
  // Устанавливает ID. После установки ID, считается, что сущность уже есть в
  // базе, поскольку ID формируется сервером.
  procedure SetID(const value: string);
public
  property IDCar: variant read FIDCar write SetID;
  property CarOwner: TClientEntity read FCarOwner write SetCarOwner;
  property PtsSer: variant read FPtsSer write SetPtsSer;
  property PtsNum: variant read FPtsNum write SetPtsNum;
  property PtsDate: variant read FPtsDate write SetPtsDate;
  property IDCarMark: variant read FCarMark write SetCarMark;
  property CarMarkName: variant read GetCarMarkName;
  property CarModel: variant read FCarModel write SetCarModel;
  property VIN: variant read FVIN write SetVIN;
  property YearIssue: variant read FYearIssue write SetYearIssue;
  property PowerKWT: variant read FPowerKWT write SetPowerKWT;
  property PowerHP: variant read FPowerHP write SetPowerHP;
  property MaxMass: variant read FMaxMass write SetMaxMass;
  property NumPlaces: variant read FNumPlaces write SetNumPlaces;
  property ShassiNum: variant read FShassiNum write SetShassiNum;
  property KusovNum: variant read FKusovNum write SetKusovNum;
  property GosNum: variant read FGosNum write SetGosNum;
  property Foreign: variant read FForeign write SetForeign;
  property InRent: variant read FInRent write SetInRent;
  property IDCarType: variant read FCarType write SetCarType;
  property CarTypeName: variant read GetCarTypeName;
  property IDPurposeUse: variant read FPurposeUse write SetPurposeUse;
  property PurposeUse: variant read GetPurposeTypeName;
  property Comments: TStringList read FComments write SetComments;
  property DateInsert: variant read FDateInsert;
  property DateUpdate: variant read FDateUpdate;
  property UserInsertName: variant read FUIName;
  property UserUpdateName: variant read FUUName;
end;

//
// Договор.
//

TContractEntity = class(TEntity)
private
protected
  procedure SetStartUse(const idx: integer; const su: variant);
  procedure SetEndUse(const idx: integer; const eu: variant);
public
  property IDContract: variant read FIDContract write SetID;
  property Car: TCarEntity read FCar write SetCar;
  property PolicyHolder: TClientEntity read FPH write SetPH;
  property Drivers: TEntityesCollection read FDrivers;
  property IDInsuranceCompany: variant read FInsComp write SetInsComp;
  property ContractType: variant read FContractType;
  property IDTerritoryUse: variant read GetTerrUse write SetTerrUse;
  property IDPrevContract: variant read FPrevCont;
  property DogSer: variant read FDogSer write SetDogSer;
  property DogNum: variant read FDogNum write SetDogNum;
  property DateCreate: variant read FDateCreate;
  property DateStart: variant read FDateStart write SetDateStart;
  property DateEnd: variant read FDateEnd write SetDateEnd;
  property InsPeriodInDays: variant read GetInsPeriod;
  property StartUse: variant index 0 read FStartUse write SetStartUse;
  property EndUse: variant index 0 read FEndUse write SetEndUse;
  property StartUse1: variant index 1 read FStartUse1 write SetStartUse;
  property EndUse1: variant index 1 read FEndUse1 write SetEndUse;
  property StartUse2: variant index 2 read FStartUse2 write SetStartUse;
  property EndUse2: variant index 2 read FEndUse2 write SetEndUse;
  property MonthsInUse: variant read GetMonthsInUse;
  property DateWrite: variant read FDateWrite write SetDateWrite;
  property DateBegin: variant read FDateBegin write SetDateBegin;
  property Transit: variant read FTransit write SetTransit;
  property UnlimitedDrivers: variant read FUDrivers write SetUDrivers;
  property IDInsuranceClass: variant read FIDInsClass write SetIDInsСlass;
  property InsSum: variant read FInsSum write SetInsSum;
  property InsPrem: variant read FInsPrem write SetInsPrem;
  property CoefTer: variant read FCoefTer write SetCoefTer;
  property CoefBonusMalus: variant read FCoefBonusMalus write SetCoefBonusMalus;
  property CoefStage: variant read FCoefStage write SetCoefStage;
  property CoefUnlim: variant read FCoefUnlim write SetCoefUnlim;
  property CoefPower: variant read FCoefPower write SetCoefPower;
  property CoefPeriodUse: variant read FCoefPeriodUse write SetFCoefPeriodUse;
  property CoefSrokIns: variant read FCoefSrokIns write SetCoefSrokIns;
  property CoefKN: variant read FCoefKN write SetCoefKN;
  property BaseSum: variant read FBaseSum write SetBaseSum;
  property TicketSer: variant read FTicketSer write SetTicketSer;
  property TicketNum: variant read FTicketNum write SetTicketNum;
  property TicketDate: variant read FTicketDate write SetTicketDate;
  property Comments: TStringList read FComments write SetComments;
  property DateInsert: variant read FDateInsert;
  property DateUpdate: variant read FDateUpdate;
  property UserInsertName: variant read FUIName;
  property UserUpdateName: variant read FUUName;

  property ZnakSer: variant read FZnakSer write FZnakSer; deprecated;
  property ZnakNum: variant read FZnakNo write FZnakNo; deprecated;

  function ContractClose(): boolean;
  function ContractReplace(): boolean;
  function ContractProlong(): boolean;
  function DriverAdd(): TDriverEntity;
  function DriverDel(driver: TDriverEntity): boolean;
  function DriverDel(id_driver: variant): boolean; overload;
end;

//
// Водитель.
//


TDriverEntity = class(TEntity)
private
public
  property IDDriver: variant read FIDDriver;
  property Client: TClientEntity read FClient write SetClient;
  property OwnerContract: TContractEntity read FContract;
  // Не имеет значения. В БД всегда равно OwnerContract.Car.
  // property Car: TCarEntity read FCar write SetCar;
  property DateInsert: variant read FDateInsert;
  property DateUpdate: variant read FDateUpdate;
end;

//
// Бланк.
//

TBlankEntity = class(TEntity)
public
  property InsuranceCompany: TInfInsCompany read FInsComp;
  property DogSer: variant read FDogSer;
  property DogNum: variant read FDogNum;
  property IDBSOStatus: variant read FBSOStatus;
  property HostReserver: variant read FHostReserver;
  property UserReserver: variant read FUserReserver;
  property DateInsert: variant read FDateInsert;
  property DateUpdate: variant read FDateUpdate;
  property Reserved: boolean read GetReserved write SetReserved;
  property BlankFullNum: variant read GetBlankFullNum;
  function BlankReserve(): boolean;
  function BlankUnreserve(): boolean;
  function BlankDamage(): boolean;
end;

//
// Страховая компания.
//

TInfInsCompany = class(TEntity)
private
public
  property IDInsCompany: variant read FIDInsCompany;
  property InsCompanyName: variant read FInsCompanyName write SetInsCompanyName;
  property Address: variant read FAddress write SetAddress;
  property Phone: variant read FPhone write SetPhone;
  property Fax: variant read FFax write SetFax;
  property Comments: TStringList read FComments write SetComments;
  property TicketBody: TMemoryStream read FTicketBody write SetTicketBody;
public
  property Blanks: TEntityesCollection read FBlanks;
  function BlankAdd(const ser, num: variant): TBlankEntity;
  function BlankDel(driver: TBlankEntity): boolean;
  function BlankDel(const ser, num: variant): boolean; overload;
end;


//
// Пользователь.
//

TUserEntity = class(TEntity)
private
public
  property Host: string read FHost write SetHost;
  property User: string read FUser write SetUser;
  property IDGroup: variant read FIDGroup write SetIDGroup;
  // Динамически возвращается из коллекции.
  property UserGroup: TGroupEntity read GetUserGroup;
  property UserSurname: variant read FUserSurname write SetUserSurname;
  property UserName: variant read FUserName write SetUserName;
  property UserPathronimyc: variant read FUserPathr write SetUserPathr;
  property Address: variant read FAddress write SetAddress;
  property PhoneHome: variant read FPhoneHome write SetPhoneHome;
  property CellPhone: variant read FCellPhone write SetCellPhone;
  property Comments: TStringList read FComments write SetComments;
  // Устанавливается в NULL, при загрузке или сохранении сущности.
  property Password: variant read FPassword write SetPassword;
  // Настройки из другой таблицы.
  property MwWidth: variant read FMwWidth write SetMwWidth;
  property MwHeight: variant read FMwHeight write SetMwHeight;
  property MwLeft: variant read FMwLeft write SetMwLeft;
  property MwTop: variant read FMwTop write SetMwTop;
  property MwState: TWindowState read FMwState write SetMwState;
  property UseHelper: boolean read FUseHelper write SetUseHelper;
  property FirstRun: boolean read FFirstRun write SetFirstRun;
public
  function SaveSettings(): boolean;
end;

//
// Группа.
//

TGroupPrivs = (Priv_cln_add, Priv_cln_chg, Priv_cln_del,
  Priv_car_add, Priv_car_chg, Priv_car_del, Priv_cont_add, Priv_cont_chg,
  Priv_cont_del, Priv_cont_prolong, Priv_cont_replace, Priv_cont_close,
  Priv_user_add, Priv_user_chg, Priv_user_del, Priv_group_add, Priv_group_chg,
  Priv_group_del, Priv_blanks, Priv_infos_edit);

TGroupEntity = class(TEntity)
private
protected
  GetPriv(const AIndex: integer);
public
  property IDGroup: variant read FIDGroup;
  property GroupName: variant read FGroupName write SetGroupName;
  property GroupDescr: TStringList read FGroupDescr write SetGroupDescr;
  property Privileges[AIndex: TGroupPrivs]: boolean read GetPriv write SetPriv;
    default;
end;

СЛОЙ ВЗАИМОДЕЙСТВИЯ С СУБД

Данный слой представлен объектом, специфичным для Delphi-подобных сред:
модулем данных. Данный модуль содержит компоненты и прочие конструкции,
оперирующие с данным и предоставляющие результат для других слоёв.

РАЗНОЕ

Запрос на выборку лиц, имеющих отношения друг с другом.
Выбирает всех лиц, которые состоят в отношениях.
Т.е., например, собственник ТС и родственники собственника.
Или владелец ТС и водители, работающие на владельца.

1.) Выбрать ID ТС из всех договоров данного страхователя.
select ID_CAR from dogovor
where dogovor.ID_CLIENT = :cln_id
2.) Выбрать все договора, заключённые на данные ТС.
select ID_DOGOVOR from dogovor
where dogovor.ID_CAR in (1)
or dogovor.ID_CLIENT = :cln_id
3.) Выбрать всех водителей для списка договоров.
select * from client, drivers
where drivers.ID_DOGOVOR in (2)
and (client.ID_CLIENT = drivers.ID_CLIENT)

Запрос:

select
distinct client.ID_CLIENT,
CONCAT_WS(" ", client.surname, client.name, client.middlename)
as FULL_NAME
from client, drivers
where drivers.ID_DOGOVOR in
(
  select ID_DOGOVOR from dogovor
  where dogovor.ID_CAR in
  (
    select ID_CAR from dogovor
    where dogovor.ID_CLIENT = :cln_id
  )
)
and (client.ID_CLIENT = drivers.ID_CLIENT)
order by FULL_NAME;


Microsoft Agent доступны все теги, принятые в SAPI, - они и позволяют сделать
речь естественной.
Emp - ударение на произносимом слове. Выделяемое речью слово должно следовать
сразу за тегом;
Chr - Устанавливает тип голоса ("Normal" - нормальный голос,
"Monotone" - монотонный, "Whisper" - шепот). Пример: '\Chr="Whisper"\Hello'
Ctx - Устанавливает тип содержимого читаемой строки ("Address" - Адрес и/или
телефонный номер, "E-mail" - мыло, "Unknown" - неопределенный тип).
Пример '\Ctx="E-mail"\asd@mail.ru'
Lst - Повторить последнее сказанное выражение;
Pau - пауза в речи (миллисекунды);
Pit - высоты звучания голоса в Гц;
Spd - средняя скорость речи (слов в минуту);
Vol - средняя громкость звука. 

Char.Speak('Привет! \spd= 150\\pit=230\Я очень рад всех вас видеть','');
Char.Speak('Привет! Я очень рад всех вас видеть.', 'Hello.Wav');

OnFilterRecord:
Accept := (Edit1.Text = '') or (Pos(AnsiUpperCase(Edit1.Text), AnsiUpperCase(Table1.FieldByName('Pole1').AsString))=1);

"Программный продукт
рекомендован
оперативно - информационным
интернет ресурсом
ГАИ ГИБДД
www.gai.ru"
Попробовать получить рекомендацию в ГАИ (для страховой версии).

# Определите роль агента.
# Дайте возможность пользователю выбрать - использовать им персонаж или нет.
# Обеспечьте обратную связь с ассистентом (персонажем).
Связь можно обеспечить как через привычный интерфейс, например контекстное меню
персонажа, так и через более "навороченный" - набор голосовых команд.
# Рационально используйте анимации. Не следует делать так, чтобы Ваш персонаж
постоянно нарезал круги по рабочему столу и махал руками - в очень короткий
срок такой персонаж будет отключен и забыт пользователем.
# Подготовьте синонимичные ответы пользователю. Например, если Вы планируете
использовать MS Agent для замены окон с ошибками, то следует предусмотреть
реакции (анимацию, движение) и правильность построения фраз персонажа.
От этого в большой степени зависит понравиться ли пользователю использование
агента или нет.

ХРАНЕНИЕ НАСТРОЕК

Настройки делятся на два класса:
1.) Сохраняемые локально.
   Эти настройки хранятся на локальной машине, с которой запускается клиент.
   Они содержат только те настройки, которые нельзя прочитать из БД.
   Это параметры подключения и место для хранения настроек.
2.) Сохраняемые в БД.
   Эти настройки хранятся на сервере.
   Подразделяются на следующие типы:
      1. Глобальные настройки, изменяемые администратором.
      2. Настройки пользователя, индивидуальные для каждого пользователя.

Обобщённый алгоритм чтения локальных настроек:
1.) Прочитать файл настроек, в каталоге программы.
2.) Прочитать индивидуальный файл настроек в каталоге пользователя.
   Индивидуальные настройки заменяют глобальные.

ТАБЛИЦЫ БАЗЫ ДАННЫХ

I. Справочники.
   1.) regiones - субъекты федерации. Таблицы departments, config.
      а.) k REGION_CODE (старый REGIONCODE _слитно_).
      б.) REGION_NAME.
      в.) ID_REGION_GROUP - идентификатор группы региона.
   2.) type_lossed - тип пострадавшего (пассажир, пешеход и т.д.).
      Используется таблицей client.
      а.) k ID_TYPE_LOSSED.
      б.) TYPE_LOSSED.
   3.) territory_use - территориальные коэффициенты.
      а.) k ID_TERRITORY_USE - код записи.
      б.) ID_REGION_GROUP - код группы региона.
      в.) ID_CAR_TYPE - код типа транспортного средства.
      г.) TERRITORY_KOEF - значение коэффициента.

   4.) valuta - валюта (RUR, USD, EUR).
      а.) k ID_VALUTA.
      б.) VALUTA_NAME.
   5.) insurance_company - страховые компании.
      а.) k ID_INSURANCE_COMPANY - код записи.
      б.) INSURANCE_COMPANY - название компании.
      в.) ADDRESS - адрес компании.
      г.) PHONE - телефоны компании.
      д.) FAX - факс компании.
      е.) COMMENTS - комментарии.
   6.) self_info - Данные о текущей БД.
      а.) DB_MAJOR_VERSION - версия БД. Должна использоваться БД,
         соответствующая версии программы. При изменении БД и программы, поле
         меняется.
      б.) DB_SUB_VERSION - подверсия. Меняется при измененииях не приводящих к
         несовместимости с клиентом. Например, алгоритмов хранимых процедур в
         БД.
      в.) CLIENT_VERSION - версия клиента, соответствующая данной БД.
      г.) BLANK_MULTIRESERVE - опция множественного резервирования бланков.
      д.) MAX_QUERIES_PER_HOUR - ограничение по умолчанию. Число запросов в час.
      е.) MAX_UPDATES_PER_HOUR - ограничение по умолчанию. Число обновлений
        в час.
      ж.) MAX_CONNECTIONS_PER_HOUR - ограничение по умолчанию. Число соединений
        в час.
      з.) MAX_USER_CONNECTIONS - ограничение по умолчанию. Число одновременных
        соединений.
      и.) REFRESH_TIME - время обновления для клиента.
   7.) ins_koefs_ko - таблица коэффициента КО.
     а.) KO_LIMITED - КО для огр. круга лиц.
     б.) KO_UNLIM - КО для неогр. круга лиц.
   8.) ins_koefs_kvs - КВС
     а.) k MAX_AGE - макс. возраст водителя.
     б.) k MAX_STAGE - макс. стаж водителя.
     в.) KVS - значение коэффициента.
   9.) ins_koefs_km - КМ.
     а.) k MAX_POWER - макс. мощность. NULL, если не определена.
     б.) KM - значение коэффициента.
   10.) ins_koefs_ks - КС.
     а.) k PERIOD_USE - период использования ТС в месяцах.
     б.) KS - значение коэффициента.
   11.) ins_koefs_kp - КП.
     а.) k PERIOD_INS - срок страхования.
     б.) KP - значение коэффициента.
   12.) ins_koefs_other - другие страховые коэффициенты.
     а.) KBM_FOREING - КБМ для иностранцев.
     б.) KVS_FOREING - КВС для иностранцев.
     в.) KO_FOREING_PHYS - КО для иностранных физ. лиц.
     г.) KO_FOREING_JUR - КО для иностранных юр. лиц.
     д.) KN - КН.
     е.) KP_TRANSIT - КП для владельцев транспортных средств, следующих
       к месту регистрации.

   -13.) incident_types - типы происшествий (смерть, разновидности травм,
      инвалидности). Не используется. Таблица suffering_face.
      а.) k INCIDENT_TYPE_CODE.
      б.) INCIDENT_TYPE.
   -14.) accident_place - место аварии. Не используется. Таблица loss.
      а.) k ID_ACCIDENT_PLACE
      б.) ACCIDENT_PLACE.
   -15.) failure_type - тип отказа. Не используется. Таблицы loss, act_detail.
      а.) k ID_FAILURE_TYPE.
      б.) FAILURE_TYPE.
   -16.) circumstance - обстоятельства наступления случая (напр. "на стоянке").
      Не используется. Таблица loss_car.
      а.) k ID_CIRCUMSTANCE.
      б.) CIRCUMSTANCE.
   -17.) crash_place - место повреждения (напр. "Перед левая сторона").
      Не используется. Таблица loss_car.
      а.) k ID_CRASH_PLACE.
      б.) CRASH_PLACE.
   -18.) device_type - тип расходов (напр. "Расходы на погребение").
      Не используется. Таблица accounting_detail.
      а.) k ID_DEVICE_TYPE.
      б.) DEVICE_TYPE.

II. Клиенты.
   1.) family_state - семейное положение.
      а.) k ID_FAMILY_STATE.
      б.) FAMILY_STATE_NAME.
   2.) sex - социальный статус (М, Ж, несовершеннолетний и т.д.)
      а.) k ID_SEX
      б.) SEX_NAME.
   3.) client_types - типы клиентов (иное юр. лицо, сотрудник ГУИН,
      иное физ. лицо и т.д.).
      а.) k ID_CLIENT_TYPE
      б.) CLIENT_TYPE
      в.) ID_CLIENT_TYPE_GROUP.
   4.) type_doc - тип удостоверения личности (паспорт, свид-во и т.д.).
      а.) k ID_TYPE_DOC.
      б.) DOC_TYPE.
   5.) client - данные о клиенте.
      1.)  k ID_CLIENT - код клиента.
      2.)  SURNAME - фамилия клиента.
      3.)  NAME - имя клиента.
      4.)  MIDDLENAME - отчество клиента.
      5.)  INN - ИНН юридического лица.
      6.)  ID_TYPE_DOC - код типа документа.
      7.)  DOC_SER - серия дкумента.
      8.)  DOC_NUM - номер документа.
      9.)  POSTINDEX - почтовый индекс
      10.) COUNTRY - страна местонахождения.
      11.) BIRTHDAY - дата рождения физического лица или регистрации юр. лица.
      12.) REGION_CODE - код региона.
      13.) TOWN - город.
      14.) STREET - улица.
      15.) HOME - дом.
      16.) KORPUS - корпус.
      17.) FLAT - номер квартиры.
      18.) HOME_PHONE - номер домашнего телефона.
      19.) CELL_PHONE - номер сотового телефона.
      20.) BUSINESS_PHONE - номер рабочего телефона.
      21.) ID_SEX - код социального положения.
      22.) ID_FAMILY_STATE - код семейного положения.
      23.) ID_CLIENT_TYPE - код типа клиента.
      24.) ID_INSURANCE_CLASS - код класса страхования клиента.
      25.) LICENCE_SER - серия водительского удостоверения.
      26.) LICENCE_NO - номер водительского удостоверения.
      27.) START_DRIVING_DATE - дата начала вождения.
      28.) DATE_INSERT - дата вставки записи.
      29.) DATE_UPDATE - дата обновления записи.
      30.) ID_TYPE_LOSSED - код типа повреждения.
      31.) COMMENTS - комментарии.
      32.) USER_INSERT_NAME - имя пользователя, добавившего запись.
      33.) USER_UPDATE_NAME - имя пользователя, обновившего запись.
   6.) client_type_group - группа клиентов (физ. лицо, юр. лицо).
      а.) k ID_CLIENT_TYPE_GROUP.
      б.) CLIENT_TYPE_GROUP.
   7.) insurance_class - класс страхования.
      а.) k ID_INSURANCE_CLASS.
      б.) KOEF.
      в.) INSURANCE_CLASS.
III. Договора.
   1.) dogovor - договор с клиентом.
      1.)  k ID_DOGOVOR - код записи.
      2.)  DOG_SER - серия договора.
      3.)  DOGNUMB - номер договора.
      4.)  DATE_DOG_CREATE - дата создания договора.
      5.)  DATE_START - дата начала действия договора.
      6.)  DATE_END - дата окончания страхования.
      7.)  START_USE - начало первого периода использования ТС.
      8.)  END_USE - конец первого периода использования ТС.
      9.)  START_USE1 - начало второго периода использования ТС.
      10.) END_USE1 - конец второго периода использования ТС.
      11.) START_USE2 - начало третьего периода использования ТС.
      12.) END_USE2 - конец третьего периода использования ТС.
      13.) ZNAK_SER - серия специального знака.
      14.) ZNAK_NO - номер специального знака.
      15.) COMMENT - комментарий.
      16.) ID_CLIENT - код страхователя.
      17.) ID_DOGOVOR_TYPE - код типа договора.
      18.) ID_INSURANCE_COMPANY - код страховой компании.
      19.) TRANSIT - флаг проезда следования ТС к месту назначения (транзит).
      20.) ID_CAR - код ТС.
      21.) ID_TERRITORY_USE - код территории использования.
      22.) UNLIMITED_DRIVERS - флаг неограниченного числа водителей.
      23.) INS_SUM - сумма страхования.
      24.) INS_PREM - страховая  премия.
      25.) KOEF_TER - значение территориального коэффициента.
      26.) KOEF_BONUSMALUS - значение коэффициента бонус-малус.
      27.) KOEF_STAG - значение коэффициента стажа и возраста.
      28.) KOEF_UNLIMITED - значение коэффициента неограниченного использования.
      29.) KOEF_POWER - значение коэффициента мощности.
      30.) KOEF_PERIOD_USE - значение коэффициента периода использования.
      31.) KOEF_SROK_INS - значение коэффициента срока страхования.
      32.) KOEF_KN - значение коэффициента грубых нарушений.
      33.) BASE_SUM - значение базовой ставки.
      34.) ID_INSURANCE_CLASS - код класса страхования.
      35.) DATE_WRITE - дата подписания.
      36.) DATE_BEGIN - дата вступления договора в силу.
      37.) ID_PREV_DOG - код предыдущего договора.
      38.) DATE_INSERT - дата вставки записи.
      39.) DATE_UPDATE - дата обновления записи.
      40.) USER_INSERT_NAME - имя пользователя, добавившего запись.
      41.) USER_UPDATE_NAME - имя пользователя, обновившего запись.
   2.) dogovor_type - тип договора (основной, пролонгированный, взамен).
      а.) k ID_DOGOVOR_TYPE.
      б.) DOGOVOR_TYPE.
   3.) dogovor_state - состояние договора (расторгнут, заключён,
      заявление и т.д.)
      а.) k ID_DOGOVOR_STATE.
      б.) DOGOVOR_STATE.
   4.) dogovor_history - история договоров.
      а.) k ID_DOGOVOR_HISTORY - код записи.
      б.) EVENT_DATE - дата события.
      в.) ID_DOGOVOR - код договора.
      г.) ID_DOGOVOR_STATE - состояние договора.
      д.) DATE_INSERT - дата вставки записи.
      е.) DATE_UPDATE - дата обновления записи.
   5.) drivers - водители.
      а.) k ID_DRIVER.
      б.) ID_CAR.
      в.) ID_CLIENT.
      г.) ID_DOGOVOR.
      д.) DATE_INSERT.
      е.) DATE_UPDATE.
   6.) blanks_journal - журнал бланков строгой отчётности.
      а.) k DOG_SER - серия договора.
      б.) k DOGNUMB - номер договора.
      в.) k ID_INSURANCE_COMPANY - код, выдавшей договор, компании.
      г.) ID_BSO_STATUS - код состояния бланка.
      д.) USER_RESERVER - пользователь, зарезервировавший бланк.
      е.) HOST_RESERVER - хост, зарезервировавший бланк.
      ж.) DATE_INSERT - дата вставки записи.
      з.) DATE_UPDATE - дата обновления записи.
   7.) bso_status - состояние бланка строгой отчётности.
      а.) k ID_BSO_STATUS - код записи.
      б.) BSO_STATUS - название состояния.
IV. Машины.
   1.) carmark - марка машины.
      а.) k ID_CARMARK.
      б.) CARMARK.
   2.) car_type - тип машины (прицеп, автобус, легковая и т.д.).
      а.) k ID_CAR_TYPE.
      б.) CAR_TYPE.
   3.) producter_type - тип производителя (имп., отеч.).
      а.) k ID_PRODUCTER_TYPE.
      б.) PRODUCTER.
   4.) car - данные о машинах клиентов.
      1.) k ID_CAR - код записи.
      2.)  ARENDA - флаг сдачи в аренду.
      3.)  ID_PURPOSE_TYPE - код цели использования.
      4.)  ID_CAR_TYPE - код типа ТС.
      5.)  ID_PRODUCTER_TYPE - код типа производителя.
      6.)  ID_CLIENT - код владельца.
      7.)  PTS_DATE - дата выдачи паспорта технического средства (ПТС).
      8.)  PTS_SER - серия ПТС.
      9.)  PTS_NO - номер ПТС.
      10.) CAR_MARK - код марки ТС.
      11.) CAR_MODEL - модель ТС.
      12.) VIN_NUM - Vehicle Identification Number. Уникальный код ТС.
      13.) YEAR_ISSUE - год выпуска ТС.
      14.) POWER_KVT - мощность двигателя в киловаттах.
      15.) POWER_LS - мощность двигателя в лошадиных силах.
      16.) MAX_KG - разрешённая максимальная масса в кг.
      17.) NUM_PLACES - число пассажирских мест.
      18.) SHASSI - номер шасси.
      19.) KUSOV - номер кузова.
      20.) GOS_NUM - государственный регистрационный номер.
      21.) FOREING - флаг использования на территории иностранного государства.
      22.) COMMENTS - комментарии.
      23.) DATE_INSERT - дата вставки записи.
      24.) DATE_UPDATE - дата обновления записи.
      25.) USER_INSERT_NAME - имя пользователя, добавившего запись.
      26.) USER_UPDATE_NAME - имя пользователя, обновившего запись.
   5.) purpose_type - цель использования машины (личная, учебная и т.д.).
      а.) k ID_PURPOSE_TYPE.
      б.) PURPOSE_TYPE.
   6.) base_sum - базовая ставка.
      Используется для расчёта страховой премии.
      а.) k ID_CAR_TYPE.
      б.) k ID_CLIENT_TYPE_GROUP.
      в.) BASE.

V. Пользователи и группы.
   1.) user - служебная таблица в БД mysql.
      Содержит:
         а.) k User.
         б.) k Host.
         в.) Пароли.
         г.) Права.
         д.) Ограничения ресурсов.
         е.) Параметры шифрования.
   2.) user_data - данные пользователей в БД программы.
      Хранимая процедура передаёт по запросу данные только пользователя с
      данным Host и User.
      Поля:
         а.) k Host. 
         б.) k User - логин.
         в.) id_group - группа пользователя. Используется хранимыми процедурами.
         г.) Surname.
         д.) Name.
         е.) Patronymic - отчество.
         ж.) Address.
         з.) Home_phone.
         и.) Cell_phone.
         к.) Call_type - тип обращения (по имени, ФИО, ИО).
         л.) Comments.
   3.) user_settings - настройки пользователя.
      Настройки пользователя хранятся в БД.
      Хранимая процедура передаёт по запросу данные только пользователя с
      данным Host и User.
      Поля:
         а.) k Host. 
         б.) k User - логин.
         в.) mw_width - ширина окна.
         г.) mw_height - высота окна.
         д.) mw_left - x окна.
         е.) mw_top - y окна.
         ж.) mw_state - состояние окна (Normal|Maximized).
         з.) use_helper - использовать помощника.
         и.) 
   4.) user_groups - группы пользователей.
      Права более высокого уровня (проверяются процедурами). Права типа bool.
      Названия групп.
         а.) k id_group.
         б.) group_name - название группы.
         в.) group_descr - описание группы.
         Права группы:
           1. priv_blanks - право на добавление/удаление/изменение
             пустых бланков полисов.
           2. priv_cln_add - право на добавление клиента.
           3. priv_cln_chg - изменение клиента.
           4. priv_cln_del - удаление клиента.
           5. priv_car_add - право на добавление ТС.
           6. priv_car_chg - изменение ТС.
           7. priv_car_del - удаление ТС.
           8. priv_cont_add - право на добавление договора.
           9. priv_cont_chg - изменение договора.
           10. priv_cont_del - удаление договора.
           11. priv_cont_prolong - пролонгация договора.
           12. priv_cont_replace - замена договора.
           13. priv_cont_close - закрытие договора.
           14. priv_user_add - добавление пользователя.
           15. priv_user_del - удаление пользователя.
           16. priv_user_chg - изменение пользователя.
           17. priv_group_add - добавление группы.
           18. priv_group_del - удаление группы.
           19. priv_group_chg - изменение группы.
           20. priv_infos_edit - прямое изменение справочников БД.

АЛГОРИТМЫ РАБОТЫ

I. Редактор договоров. Описание алгоритма работы.
Редактор договоров представляет собой окно, содержащее несколько вкладок.
На вкладках поля договора.
   1.) Перед показом редактора, поля заполняются значениями, взятыми из
      выбранного договора или очищаются, если договор не выбран.
   2.) Если у пользователя нет прав на изменение договора, поля деактивируются.
   3.) Имея полные права, пользователь может как менять, так и добавлять договора.
      Занесение изменений в БД производится только после нажатия кнопки "Ok".
   4.) Когда пользователь нажимает кнопку "Новый", поля очищаются.
      Кнопки "Пролонг.", "Заменить", "Закрыть" блокируются.
      Затем, устанавливается флаг, определяющий, что договор создаётся.
   5.) При нажатии кнопки "Отмена", повторном нажатии кнопки "Новый" или
      попытке открытия другого договора из окна поиска, пользователю выдаётся
      запрос. Если ответ отрицательный, действие отменяется.
      Иначе теряются все изменения в новом договоре и выполняется действие.
   6.) При изменении какого либо поля, устанавливается флаг, определяющий начало
      процесса изменения договора. Реакции на события аналогичны реакциям, при
      нажатии на кнопку "Новый".
   7.) После нажатия кнопки "Ok", вызывается метод, которому передаются
      параметры и флаги.
      Метод, по флагам определяет какой запрос вызвать: на изменение или на
      добавление.
   8.) При выборе ТС, открывается окно менеджера ТС, в котором изменяется
      указатель на текущую запись запроса, отбирающего данные о ТС.
   9.) При выборе страхователя или владельца, открывается окно менеджера
      клиентов. После закрытия проверяется модальный результат.

II. Серверные процедуры.

  1.) Основные группы пользователей:
    1. Администраторы. Г1.
    2. Доверенные пользователи. Г2.
    3. Обычные пользователи. Г3.

  Далее, рядом с каждой процедурой указаны группы, с минимальными правами,
  которым разрешено её использование.
  Г3 имеет наименьшие права. Т.е., если указана она, то использовать проц-ру
  разрешается всем. Реально, разрешение использования, реализуется установкой
  прав в таблице прав группы.

  2.) Общая структура серверной процедуры.
    1. Получение ID пользователя.
    2. Получение группы пользователя.
    3. Выбор из таблицы прав группы.
    4. Проверка на права для данной процедуры.
    5. Выполнение кода процедуры или выход.

  3.) Список серверных процедур.
    1. Ведение базы клиентов.
      а.) Добавить клиента. ClnAdd. Г3.
      б.) Изменить клиента. ClnChg. Г3.
      в.) Проверить существование клиента. ClnExists. Г3.
      г.) Удалить клиента. ClnDel. Заглушка. Г1.
      д.) Поиск. ClnSearch. Не реализовано. Г3.
    2. Ведение БД транспортных средств.
      а.) Добавить ТС. CarAdd. Г3.
      б.) Изменение. CarChg. Г3.
      в.) Проверить существование ТС. CarExists. Г3.
      г.) Удаление. CarDel. Заглушка. Г1.
      д.) Поиск. CarSearch. Не реализовано. Г3.
    3. Ведение БД договоров.
      а.) Добавление. ContAdd. Г3.
      б.) Изменение. ContChg. Г2.
      в.) Проверить существование договора. ContExists. Г3.
      г.) Пролонгация договора. ContProlong. Г3.
      д.) Замена договора. ContReplace. Г3.
      е.) Закрытие договора. ContClose. Г2.
      ж.) История договоров. ContHistory. Г3.
      з.) Удаление. ContDel. Г1.
      и.) Поиск. ContSearch. Не реализовано. Г3.
      к.) Резервирование пустого бланка. BlankReserve. Г3. Права на добавление.
      л.) Разрезервирование пустого бланка. BlankUnreserve. Г3.
        Права на добавление.
      м.) Добавление пустого бланка полиса. BlankAdd. Г2.
    4. Работа с пользователями и группами.
      а.) Получить данные текущего пользователя. UserGetCurrent. Г3.
      б.) Получить данные группы текущего пользователя. GroupGetCurrent. Г3.
      в.) Добавить пользователя. UserAdd. Г1.
      г.) Удалить пользователя. UserDel. Г1.
      д.) Изменить пользователя. UserChg. Г1.
      е.) Добавить группу. GroupAdd. Заглушка. Г1.
      ж.) Удалить группу. GroupDel. Заглушка. Г1.
      з.) Изменить группу. GroupChg. Заглушка. Г1.
    5. Общие процедуры.
      а.) Получение ID группы пользователя. GetGroupID. Г3.
      б.) Получение уникального ID пользователя. GetUserID. Г3.
      в.) Выполнить произвольный запрос. ExecQuery. Г1.

НЕОБРАБОТАННОЕ

Минимальный срок - месяц.

  Импорт-экспорт БД.

Если выдаётся квитанция, это означает, что договор вступает в силу?
   Квитанции не учитываются. В дополнительные возможности.
37.) Нужна ли квитанция?
   Квитанции не учитываются. В дополнительные возможности.
   Формы квитанции разнятся от компании к компании.

11.) Доп.
  Контрол с выбором группы договоров по Ctrl и Shift.
  

ДОПОЛНИТЕЛЬНО

Должна иметься возможность подключения с любого клиента,
имеющего выход в сеть. Авторизация должна проводиться средствами сервера.
Текущая программа использует локальную БД. Общий доступ реаллизован поверх
протокола NetBIOS или, как его-там, короче "Общие папки" виндовса.

Во всех программах сложный, малопонятный и неудобный интерфейс.

ТЕКУЩАЯ ПРОГРАММА


Возможности:
Возможность учета бланков строгой отчетности.
Клиентская и серверная часть.

Возможность ввода пролонгированных договоров и договоров выданных в замен.
В "Журнале договоров" кнопки "Пролонгация", "Замена" соответственно. 

Возможность одновременной загрузки нескольких файлов передачи данных.
Для этого необходимо поместить файлы передачи данных в каталог откуда
производится загрузка данных и нажить кнопку "Каталог" в  диалоге загрузки
данных.

На основании введенных убытков возможно готовить данные для РСА и 
Министерства по налогам.
Убытки делятся на заявленные и урегулированные. Так же введено разделение
убытков на имущество/здоровье/жизнь. Привязка выплаты осуществляется к
страховому акту, а не к убытку.

Выгрузка полисов ОСАГО в 1С, АИС, Excel.
Для экспорта договоров из ПФК ОСАГО в 1С необходимо использовать средства 1С.

Возможность вводить договора ОСАГО для юридических лиц используя бордеро.
Шаблон бордеро находится в каталоге C:\OSAGO по именем BORDEROJUR.XLT.

Возможность удаления договоров страхования. В "Журнале договоров" кнопка
"Удалить"
Возможность расторжения договоров. В "Журнале договоров" кнопка "Конец".
Возможность импорта заявлений на страхование из Интернет-магазина в ПФК ОСАГО.

Печать полиса.
Журнал убытков, журнал договоров, 

ОПИСАНИЕ ФИРМЫ

Брокерские услуги в сфере страхования. Консалтинг, продажа полисов, сбор и
оформление всех необходимых для страхования документов. Юридические услуги.

РАЗНОЕ

"Практика показала, что во время оформления договоров по ОСАГО из-за заполнения
многочисленных документов тратится достаточно много времени. Для того чтобы
сэкономить минуты клиентов и обеспечить максимальный комфорт была разработана
система автоматизации рабочего места.
Компьютерная программа позволяет быстро рассчитывать тариф и автоматически
заполняет все необходимые документы. В настоящее время система работает в
нескольких страховых компаниях. Программный продукт представляет собой
самостоятельный исполняемый файл, что позволяет не зависеть от дополнительного
ПО, и полностью автоматизировать оформление и печать полисов, заключение
договоров и производство последующих отчетов полисов ОСАГО.
Интуитивный интерфейс программы и максимально удобный оперативный ввод
информации, позволяет провести все операции по заключению договора и оформления
полиса в течении 3-4 минут реального времени.
В современных страховых компаниях документооборот по полисам (не считая
документов по взносам и выплатам) составляет сотни единиц ежедневно.
Поэтому когда возникает необходимость найти информацию о полисе, внести
изменения или произвести пролонгацию договора, составленному, например год
назад, требуется значительное количество времени. Программа ОСАГО позволяет
сделать это в считанные секунды. В этом и заключается одно из основных
преимуществ хранения информации в электронном виде.
При вводе данных программа ОСАГО может автоматически заполнять некоторые поля,
например: автоматически вычислять комиссии агентов, рассчитывать период
использования, сроки страхования, стаж лиц допущенных к управлению т.п."

"Страховой брокер 8.3":
http://knopka1.ru/x-strahovoy-broker/x-strahovoy-broker.html

"Аналитик-страхование":
http://broker-demo.narod.ru



"ОСАГО 2009":
-        Поддержка пользователей по телефону в удобное время.
-        Возможность печати и предварительного просмотра: заявления, полиса, подложки полиса.
-        Возможность сортировки отчета по дате оформления полисов.
-        Автоматический расчет дат начала, окончания и периода использования срока действия договора.
-        Автоматическое заполнение данных владельца по данным страхователя.
-        Отсутствие зависимости от используемых шрифтов операционной системой пользователя.
-        Функция резервного копирования.
-        Возможность указания двух периодов с разрывом по сроку использования ТС.
-        Возможность печати индивидуальных заявлений и полисов для каждого страховщика и представителя с его информацией и данными.
-        Удобный ввод и расчет стажа водителя при ограниченной информации о дате выдачи водительского удостоверения.
-        Умные автоматические подсказки с цитатами из методических указаний РСА.
"

"Мейер - ОСАГО":
"
Создание и редактирование договоров ОСАГО.

    * Создание и редактирование заявления.
    * Проверка введенной информации для заявления.
    * Три вида расчета страховой премии: с точностью до копеек, по правилам округления до рубля, с округлением до рубля в большую сторону.
    * Возможность задавать регион, используемый по умолчанию в калькуляторе ОСАГО.
    * Возможность разбивать период страхования ТС на два срока.
    * Возможность создавать и учитывать пустые бланки полисов.
    * Дублирование информации о собственнике или страхователе в таблицу водителей.
    * Контроль бланков полисов (пустые, заполненные, испорченные).
    * Возможность выдавать новый полис взамен старого (из-за изменений условий страхования или утери предыдущего полиса) с учетом номера и серии предыдущего страхового полиса.
    * Возможность закрыть полис вручную.
    * Потоковый ввод договоров.

Работа с базой договоров ОСАГО.

    * Расширенный поиск договоров в базе данных.
    * Инкрементальный поиск договоров в пределах текущей папки по всем или по одному столбцу.
    * Быстрый поиск договоров в пределах текущей папки.
    * Операции: копировать, вставить, вырезать для одного или для нескольких договоров.
    * Учет даты создания, даты последнего изменения, даты последнего импорта, даты последнего экспорта договора.
    * Хранение договоров в папках с возможностью перетаскивания одного или нескольких договоров между папками.
    * Быстрая статистика по выбранной папке.
    * Индикация статуса для договоров в таблице на главном экране (активен, активен. замена, не начат, не начат. замена, завершен, завершен. замена, испорчен, закрыт).
    * Возможность сортировать договора в таблице и производить по ним инкрементальный поиск.

Печать бланков полисов, заявлений и квитанций.

    * Два варианта бланков заявлений.
    * Два варианта бланков квитанций.
    * Настройка варианта заявления и квитанции, используемых по умолчанию при печати.
    * Гибкие настройки печати бланка полиса и заявления (расположение элементов, выводимая информация, размер шрифта для бланка полиса).
    * Возможность распечатать пробный полис, имитирующий вид настоящего бланка полиса.
    * Возможность печати логотипа компании в левом верхнем углу бланка заявления.
    * Содержание особых отметок можно настраивать отдельно для бланков полиса и заявления.
    * В заявлении отображается информация о предыдущем договоре страхования: наименование страховой компании, серия и номер страхового полиса.
    * Программа может распечатывать квитанции.

Отчеты.

    * Отчет по использованию бланков строгой отчетности.
    * Отчет по заключенным договорам за определенный промежуток времени.
    * Общий отчет.

Импорт - экспорт.

    * Интеграция с 1С путем создания экспортных файлов dBASE 3, 4, 7.
    * Раздел помощи с подробной расшифровкой полей экспортных файлов.
    * Экспорт договоров в форматы XML.
    * Экспорт договоров по электронной почте в виде zip архивов.
    * Легкая миграция между различными версиями Мейер ОСАГО путем импорта-экспорта всей базы.

Администрирование.

    * Возможность выбора режима работы: сетевой, локальный.
    * Возможность восстановления базы данных с полной ее перестройкой после аварийных завершений программы, когда файлы базы данных становятся испорченными или полностью уничтожаются.
    * Два вида доступа: администратор и обычный агент.
    * Добавление в систему агентов с указанием их ФИО и пункта страхования.
    * Возможность создания резервных копий базы данных.
    * Создание ежедневных резервных копий базы данных: каждый день автоматически создается папка со снимком базы данных на данный день.
    * Возможность упаковки/очистки базы данных.

"

'В Мейер ОСАГО, как и в любой программе, могут присутствовать ошибки. В случае,
если у Вас возникла ошибка при работе с Мейер ОСАГО, на экране должно появиться
диалоговое окно с надписью "Ошибка приложения" и кнопками: "Оправить e-mail",
"Показать", "Продолжить" и "Закрыть". Для того чтобы мы могли исправить ошибку,
нам нужна информация о ней, поэтому в этой ситуации Вам следует отправить нам
отчет об ошибке, нажав кнопку "Отправить e-mail". После нажатия этой кнопки у
Вас должна автоматически запуститься почтовая программа (например, MS Outlook
Express), в которой будет готовое письмо с отчетом об ошибке, и Вам нужно будет
лишь отправить его. Письмо автоматически будет отправлено по адресу
support@meyer-nicca.com
Если у Вас автоматически не запустилась программа для отсылки писем, Вам
следует нажать кнопку "Показать". При этом в диалоговом окне раскроется
панель с текстом ошибки. Вы должны выделить и скопировать ВЕСЬ текст, который
находится в окне, и затем вручную написать нам письмо по вышеуказанному адресу,
в котором привести текст ошибки, и, желательно, снимок экрана программы в виде
рисунка (Вы можете сделать снимок, нажав клавишу PrintScreen и вставив затем
содержимое в любой графический редактор типа встроенного Paint). После чего Вы
можете возобновить работу программы, нажав кнопку "Продолжить", или выйти из
программы, нажав кнопку "Закрыть".
Мы будем очень благодарны, если Вы отправите нам отчет об ошибке программы,
если она у Вас произойдет. Мы исследуем Ваш случай и поставим его в очередь на
исправление, если сможем воспроизвести данную ситуацию. Для того, чтобы помочь
нам повторить ошибку, которая появляется в Вашей копии программы, мы просим Вас
в письме, которое Вы нам отправляете, подробно описать шаги, которые привели к
ошибке.'

'Заранее благодарим Вас за пожелания и предложения относительно улучшения работы
программы Мейер ОСАГО. Если Вы желаете внести новое предложение, или указать
существующий недостаток, пожалуйста, отправьте нам письмо по адресу:
support@meyer-nicca.com'

"Да правильно, вы не можете вручную внести номера полисов. В Мейер ОСАГО
используется специальная схема работы с пустыми бланками полисов. Номера
полисов вносятся автоматически. Мы ввели контроль бланков строгой отчетности,
для того чтобы можно было контролировать количество пустых полисов
(из соображений безопасности), а так же делать отчет по движению бланков
полисов за указанный период (Главное меню > Отчеты > Использование бланков)."

"Как выделить несколько договоров в таблице?

Есть три способа выбора нескольких договоров в таблице.

1й способ: использование клавиши Shift для выделения группы подряд идущих
договоров в списке
- Достоинства: этот способ позволяет быстро (двумя щелчками мыши) выделить сразу несколько подряд идущих договоров в списке.
- Недостатки: используя этот способ, можно выделить только группу подряд идущих договоров, а не отдельные договоры.

Пошаговая инструкция:
1. Щелкните по первому договору, который необходимо выделить.
2. Нажмите и удерживайте (не отпускайте) клавишу Shift.
3. Левой клавишей мыши щелкните по последнему договору из группы подряд идущих договоров, которые необходимо выделить (клавишу Shift не отпускайте!). При этом должна выделиться группа договоров, начиная с первого выделенного и заканчивая последним выделенным договором.

2й способ: использование клавиши Control для выделения произвольных договоров
- Достоинства: этот способ позволяет выделять нужные договоры в списке в произвольном порядке.
- Недостатки: каждый договор Вы должны выделять отдельным щелчком мыши.

Пошаговая инструкция:
1. Нажмите и удерживайте (не отпускайте) клавишу Control.
2. Левой клавишей мыши щелкните по нужному договору (при этом он выделится в списке). Щелкните по следующему договору, который необходимо выделить (клавишу Control не отпускайте!). И так щелкайте до тех пор, пока Вы не выделите все нужные Вам договоры.

3й способ: использование клавиш Control и Shift для выбора произвольных договоров и группы, подряд идущих договоров в списке. Этот способ используется для повышения эффективности работы и включает в себя оба вышеперечисленных способа.

Пошаговая инструкция:
1. Если до этого Вы выделяли договоры при помощи клавиши Control, не отпускайте ее.
2. Щелкните по первому договору, который необходимо выделить.
3. Отпустите клавишу Control, если Вы ее удерживали.
4. Нажмите и удерживайте (не отпускайте) клавишу Shift.
5. Левой клавишей мыши щелкните по последнему договору из группы подряд идущих договоров, которые необходимо выделить (клавишу Shift не отпускайте!). При этом должна выделиться группа договоров, начиная с первого выделенного и заканчивая последним выделенным договором.

Для эффективной работы можно использовать оба способа. Например, если в списке из 10 договоров нужно выделить 2-й, 4-й и с 6-го по 10-й договоры, необходимо сначала выделить первым способом (удерживая клавишу Control) 2-й и 4-й договоры, затем, не отпуская клавишу Control, выделить 6-й договор, затем отпустить клавишу Control, нажать и удерживать клавишу Shift и выделить сразу 10-й договор (используя второй способ).

Примечание: если при выделении договоров (неважно каким способом) Вы случайно допустили ошибку: выделили ненужный полис, выделение можно отменить. Для этого необходимо:
1. Отпустить все нажатые и удерживаемые клавиши.
2. Нажать и удерживать клавишу Control.
3. Левой кнопкой мыши (не отпуская клавиши Control) щелкнуть по неправильно выделенному полису. Он перестанет быть выделенным."

"Пользователь в зависимости от своей задачи может сортировать полисы по следующим критериям:
* Серия (серия полиса)
* Номер (номер полиса)
* Страхователь (Ф.И.О. страхователя)
* Премия (страховая премия)
* Статус
* Создан (дата создания полиса )
* Изменён (дата изменения полиса)
* Импортирован (дата импортирования )
* Экспортирован (дата экспортирования)
* Начало страхования
* Конец страхования
* Агент
* Изменённая сумма

Для этого Пользователю необходимо кликнуть левой кнопкой мыши по соответствующему заголовку в таблице договоров. При этом записи в таблице будут отсортированы в зависимости от выбранного критерия. Для обратной сортировки проделайте ту же операцию."

"Для калькулятора появилась возможность задавать регион, используемый по умолчанию."

"Переработана форма заявления. Теперь бланк заявления помещается на двух страницах.
В бланк заявления добавлены серия и номер полиса."

"Появилась возможность выбрать логотип компании, который будет печататься в
левом верхнем углу заявления."

"В редактор договора добавлено поле ввода для мощности в кВт.
Также производится автоматический расчет значений в л.с. из кВт и обратно.
Используется точность до сотых долей."

"возможность учета испорченных бланков полисов."

"возможность установки английского языка интерфейса."

"возможность внести водителя в базу, если у него нет водительского удостоверения."

'поле "агентское вознаграждение в %".'

Быстрый поиск.

? "возможность выдавать новый полис взамен старого (из-за изменений условий
страхования или утери предыдущего полиса) с учетом номера и серии предыдущего
страхового полиса."

"Появилась возможность задавать кодировку Windows-1251 для XML файлов экспорта.
В диалоге настроек добавлена опция для выбора кодировки XML экспорта (по умолчанию UTF8)."

'Добавлен новый диалог "переход к договору", который позволяет быстро отбирать
требуемый договор и переходить на него.'

'Полисы после восстановления действительно всегда появляются в папке "Входящие".
Дело в том, что пользователь может забыть в какой именно папке был удаленный полис'

'При печати бланка полиса на различных принтерах цифры могут быть смещены.
Решить эту проблему можно путем настройки бланка полиса под заданный принтер.
Для этого нужно выбрать вкладку: "Утилиты > Настройки > Отчеты > Полис".
При помощи бегунков можно настроить смещение по горизонтали и вертикали для
бланка полиса. '

Идентификационный номер состоит из разделов (частей), заполненных значащими символами - арабскими цифрами (0, 1, 2, 3, 4, 5, 6, 7, 8, 9) и латинскими буквами (кроме I, O, Q). Кроме того, можно применять разделители, отмечающие начало и окончание VIN, либо отделяющие друг от друга его части. Внешний вид этих знаков не регламентирован - лишь бы они не походили на значащие. 
